@page
@model AddBookModel
@{
    ViewData["Title"] = "Add Book";
}

<div class="search-page-container">
    <!-- Search Bar -->
    <div class="search-section">
        <div class="search-bar-container">
            <div class="search-input-wrapper">
                <svg class="search-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="11" cy="11" r="8"/>
                    <path d="m21 21-4.35-4.35"/>
                </svg>
                <input type="search" 
                       id="book-search" 
                       placeholder="Search for a book by title or author..." 
                       class="search-input" 
                       autocomplete="off" 
                       aria-label="Search for a book" />
                <button type="button" class="search-submit" id="execute-search">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="11" cy="11" r="8"/>
                        <path d="m21 21-4.35-4.35"/>
                    </svg>
                    Search
                </button>
            </div>
        </div>
    </div>

    <!-- Empty State (shown when no search) -->
    <div class="empty-state-container" id="empty-state">
        <div class="empty-state-content">
            <div class="book-icon">
                <svg viewBox="0 0 64 64" fill="none">
                    <path d="M10 16C10 12.6863 12.6863 10 16 10H32C35.3137 10 38 12.6863 38 16V52C38 55.3137 35.3137 58 32 58H16C12.6863 58 10 55.3137 10 52V16Z" fill="#E2F2FF"/>
                    <path d="M54 16C54 12.6863 51.3137 10 48 10H32C28.6863 10 26 12.6863 26 16V52C26 55.3137 28.6863 58 32 58H48C51.3137 58 54 55.3137 54 52V16Z" fill="#B8E0FF"/>
                    <path d="M21 24H30" stroke="#0D6EFD" stroke-width="3" stroke-linecap="round"/>
                    <path d="M21 34H30" stroke="#0D6EFD" stroke-width="3" stroke-linecap="round"/>
                    <path d="M34 24H43" stroke="#0D6EFD" stroke-width="3" stroke-linecap="round"/>
                    <path d="M34 34H43" stroke="#0D6EFD" stroke-width="3" stroke-linecap="round"/>
                </svg>
            </div>
            <h2>Add a new book to your library</h2>
            <p>Start by searching for a book by its title or author in the search bar above. We'll find it for you!</p>
            <button type="button" class="start-searching-btn" id="start-searching">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="11" cy="11" r="8"/>
                    <path d="m21 21-4.35-4.35"/>
                </svg>
                Start Searching
            </button>
        </div>
    </div>

    <!-- Search Results -->
    <div class="search-results-container" id="search-results" style="display: none;">
        <h2 class="search-results-title">Search Results</h2>
        <div id="search-feedback" class="search-feedback" style="display: none;"></div>
        <div class="search-results-list" id="results-list">
            <!-- Results will be populated by JavaScript -->
        </div>
    </div>

    <!-- Activity Log -->
    <div class="activity-log-container" id="activity-log">
        <div class="activity-log-header">
            <h2 class="activity-log-title">Activity Timeline</h2>
            <button type="button" class="clear-log-btn" id="clear-log">
                Clear log
            </button>
        </div>
        <div class="activity-log-body" id="activity-log-entries" aria-live="polite">
            <div class="activity-log-empty" id="activity-log-empty" data-empty-state>
                <p>Start a search to inspect every request and response that powers this page.</p>
            </div>
        </div>
    </div>
</div>

<div class="status-modal-backdrop" id="status-modal" hidden>
    <div class="status-modal-panel" role="dialog" aria-modal="true" aria-labelledby="status-modal-title" aria-describedby="status-modal-description" tabindex="-1">
        <button type="button" class="status-modal-close" id="status-modal-close" aria-label="Close">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
        </button>
        <header class="status-modal-header">
            <p class="status-modal-eyebrow" id="status-modal-description">Choose how you want to track this title.</p>
            <h2 class="status-modal-title" id="status-modal-title">Add to your library</h2>
            <p class="status-modal-book" id="status-modal-book"></p>
        </header>
        <div class="status-modal-options" id="reading-status-options"></div>
        <div class="status-modal-form-group">
            <label for="book-rating" class="status-modal-label">My rating (optional)</label>
            <input type="number"
                   id="book-rating"
                   class="status-modal-input"
                   name="book-rating"
                   min="0"
                   max="5"
                   step="0.5"
                   inputmode="decimal"
                   placeholder="e.g. 4.5" />
            <p class="status-modal-helper">Capture your personal score between 0 and 5.</p>
        </div>
        <div class="status-modal-form-group">
            <label for="author-avatar" class="status-modal-label">Author avatar URL (optional)</label>
            <input type="url"
                   id="author-avatar"
                   class="status-modal-input"
                   name="author-avatar"
                   maxlength="500"
                   placeholder="https://example.com/avatar.jpg" />
            <p class="status-modal-helper">We'll store this image with the author in your library.</p>
        </div>
        <div class="status-modal-form-group">
            <label for="remark-content" class="status-modal-label">Personal remark (optional)</label>
            <input type="text"
                   id="remark-title"
                   class="status-modal-input"
                   name="remark-title"
                   maxlength="200"
                   placeholder="Give your remark a short title (optional)" />
            <textarea id="remark-content"
                      class="status-modal-textarea"
                      name="remark-content"
                      maxlength="4000"
                      rows="4"
                      placeholder="Capture any thoughts you'd like to remember when you revisit this book."></textarea>
            <p class="status-modal-helper">Remark is saved privately to your library and can be edited later.</p>
        </div>
        <footer class="status-modal-footer">
            <span class="status-modal-feedback" id="status-modal-feedback" role="alert"></span>
            <button type="button" class="status-modal-submit" id="confirm-add-book">
                Add to Library
            </button>
        </footer>
    </div>
</div>

@section Scripts {
    <script>
        // Search functionality
        const searchInput = document.getElementById('book-search');
        const searchButton = document.getElementById('execute-search');
        const emptyState = document.getElementById('empty-state');
        const searchResults = document.getElementById('search-results');
        const resultsList = document.getElementById('results-list');
        const startSearchingBtn = document.getElementById('start-searching');
        const searchFeedback = document.getElementById('search-feedback');
        const activityLogEntries = document.getElementById('activity-log-entries');
        const activityLogEmpty = document.getElementById('activity-log-empty');
        const clearLogButton = document.getElementById('clear-log');
        const placeholderCover = 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="60" height="90"><rect width="100%" height="100%" fill="#e2e8f0"/><text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" font-family="Arial, sans-serif" font-size="9" fill="#64748b">No Cover</text></svg>');
        const statusModal = document.getElementById('status-modal');
        const statusModalPanel = document.querySelector('.status-modal-panel');
        const statusModalClose = document.getElementById('status-modal-close');
        const statusOptionsContainer = document.getElementById('reading-status-options');
        const statusModalBook = document.getElementById('status-modal-book');
        const statusModalFeedback = document.getElementById('status-modal-feedback');
        const confirmAddButton = document.getElementById('confirm-add-book');
        const ratingInput = document.getElementById('book-rating');
        const remarkTitleInput = document.getElementById('remark-title');
        const remarkContentInput = document.getElementById('remark-content');
        const authorAvatarInput = document.getElementById('author-avatar');

        const readingStatusOptions = [
            {
                value: 'plan-to-read',
                label: 'Save for Later',
                helper: 'Queue this title for when you have time to enjoy it.'
            },
            {
                value: 'reading',
                label: 'Currently Reading',
                helper: 'Start tracking it right away while you dive in.'
            },
            {
                value: 'read',
                label: 'Finished',
                helper: 'Log it as completed and celebrate the win.'
            }
        ];

        const normalizeRatingValue = (value) => {
            if (typeof value !== 'number' || !Number.isFinite(value)) {
                return null;
            }

            const clamped = Math.min(5, Math.max(0, value));
            return Math.round(clamped * 10) / 10;
        };

        let selectedBook = null;
        let selectedStatus = readingStatusOptions[0]?.value ?? 'plan-to-read';

        const sanitizeOptionalText = (value, maxLength) => {
            if (typeof value !== 'string') {
                return null;
            }

            const trimmed = value.trim();
            if (!trimmed) {
                return null;
            }

            if (typeof maxLength === 'number' && trimmed.length > maxLength) {
                return trimmed.slice(0, maxLength);
            }

            return trimmed;
        };

        const buildDefaultAuthorAvatar = (name) => {
            if (typeof name !== 'string' || !name.trim()) {
                return 'https://i.pravatar.cc/160?img=1';
            }

            const identifier = encodeURIComponent(name.trim().toLowerCase());
            return `https://i.pravatar.cc/160?u=${identifier}`;
        };

        initializeStatusOptions();

        startSearchingBtn?.addEventListener('click', () => {
            searchInput.focus();
        });

        searchInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                event.preventDefault();
                handleSearch();
            }
        });

        searchInput.addEventListener('input', () => {
            if (!searchInput.value.trim()) {
                showEmptyState();
            }
        });

        searchButton.addEventListener('click', handleSearch);

        clearLogButton?.addEventListener('click', resetActivityLog);

        statusModalClose?.addEventListener('click', closeStatusModal);

        statusModal?.addEventListener('click', (event) => {
            if (event.target === statusModal) {
                closeStatusModal();
            }
        });

        confirmAddButton?.addEventListener('click', submitSelectedBook);

        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' && isModalOpen()) {
                closeStatusModal();
            }
        });

        resultsList.addEventListener('click', (event) => {
            const button = event.target.closest('.add-book-btn');
            if (!button) {
                return;
            }

            const book = extractBookData(button);
            if (!book.title || !book.author) {
                logActivity('Add book blocked', {
                    details: book,
                    variant: 'error'
                });
                setFeedback('Unable to add this suggestion right now. Try searching again.', 'error');
                return;
            }

            logActivity('Add book requested', {
                details: {
                    title: book.title,
                    author: book.author
                },
                variant: 'info'
            });

            openStatusModal(book);
        });

        function showEmptyState() {
            emptyState.style.display = 'block';
            searchResults.style.display = 'none';
            resultsList.innerHTML = '';
            setFeedback('');
            if (hasActivityLogEntries()) {
                logActivity('Reset search state', { variant: 'info' });
            }
        }

        function setFeedback(message, state) {
            if (!message) {
                searchFeedback.style.display = 'none';
                searchFeedback.textContent = '';
                searchFeedback.className = 'search-feedback';
                return;
            }

            const classes = ['search-feedback'];
            if (state) {
                classes.push(state);
            }

            searchFeedback.className = classes.join(' ');
            searchFeedback.textContent = message;
            searchFeedback.style.display = 'block';
        }

        function initializeStatusOptions() {
            if (!statusOptionsContainer) {
                return;
            }

            statusOptionsContainer.innerHTML = readingStatusOptions.map((option, index) => `
                <label class="status-option">
                    <input type="radio" name="reading-status" value="${option.value}" ${index === 0 ? 'checked' : ''}>
                    <span class="status-option-content">
                        <span class="status-option-label">${option.label}</span>
                        <span class="status-option-helper">${option.helper}</span>
                    </span>
                </label>
            `).join('');

            statusOptionsContainer.addEventListener('change', (event) => {
                const input = event.target;
                if (input instanceof HTMLInputElement && input.name === 'reading-status') {
                    selectedStatus = input.value;
                    clearModalFeedback();
                }
            });
        }

        function extractBookData(button) {
            const {
                title = '',
                author = '',
                description = '',
                cover = '',
                category = '',
                quote = '',
                isbn = '',
                publicRating = ''
            } = button.dataset;

            const toNullable = (value) => {
                const trimmed = (value ?? '').trim();
                return trimmed.length > 0 ? trimmed : null;
            };

            const parsedPublicRating = Number.parseFloat(publicRating);

            return {
                title: title.trim(),
                author: author.trim(),
                description: toNullable(description),
                coverImageUrl: toNullable(cover),
                category: toNullable(category),
                quote: toNullable(quote),
                isbn: toNullable(isbn),
                publicRating: Number.isFinite(parsedPublicRating) ? parsedPublicRating : null
            };
        }

        function openStatusModal(book) {
            if (!statusModal) {
                return;
            }

            selectedBook = book;
            selectedStatus = readingStatusOptions[0]?.value ?? 'plan-to-read';

            clearModalFeedback();
            resetSupplementaryFields();

            if (statusModalBook) {
                statusModalBook.textContent = `${book.title} · ${book.author}`;
            }

            if (authorAvatarInput) {
                authorAvatarInput.value = buildDefaultAuthorAvatar(book.author);
            }

            const radios = statusOptionsContainer?.querySelectorAll('input[name="reading-status"]');
            radios?.forEach((input, index) => {
                input.checked = index === 0;
            });

            document.body.classList.add('modal-open');
            statusModal.removeAttribute('hidden');
            statusModal.classList.add('is-open');

            queueMicrotask(() => {
                const focusTarget = statusOptionsContainer?.querySelector('input[name="reading-status"]');
                if (focusTarget instanceof HTMLElement) {
                    focusTarget.focus();
                } else if (statusModalPanel instanceof HTMLElement) {
                    statusModalPanel.focus();
                }
            });
        }

        function closeStatusModal() {
            if (!statusModal) {
                return;
            }

            statusModal.classList.remove('is-open');
            statusModal.setAttribute('hidden', 'hidden');
            document.body.classList.remove('modal-open');
            selectedBook = null;
            resetSupplementaryFields();
        }

        function isModalOpen() {
            return statusModal?.classList.contains('is-open') ?? false;
        }

        function clearModalFeedback() {
            if (!statusModalFeedback) {
                return;
            }

            statusModalFeedback.textContent = '';
            statusModalFeedback.className = 'status-modal-feedback';
        }

        function setModalFeedback(message, state) {
            if (!statusModalFeedback) {
                return;
            }

            const classes = ['status-modal-feedback'];
            if (state) {
                classes.push(`status-modal-feedback--${state}`);
            }

            statusModalFeedback.className = classes.join(' ');
            statusModalFeedback.textContent = message;
        }

        async function submitSelectedBook() {
            if (!confirmAddButton) {
                return;
            }

            if (!selectedBook) {
                setModalFeedback('Select a book before adding it to your library.', 'error');
                return;
            }

            const { value: ratingValue, error: ratingError } = tryParseRating();
            if (ratingError) {
                setModalFeedback(ratingError, 'error');
                return;
            }

            const remarkPayload = buildRemarkPayload();
            const authorAvatarUrl = sanitizeOptionalText(authorAvatarInput?.value, 500);

            const payload = buildBookPayload(selectedBook, selectedStatus, {
                rating: ratingValue,
                remark: remarkPayload,
                avatarUrl: authorAvatarUrl
            });

            if (!payload.title || !payload.author) {
                setModalFeedback('We need a title and author to add this book.', 'error');
                return;
            }

            logActivity('Saving book to library', {
                details: {
                    title: payload.title,
                    author: payload.author,
                    status: payload.status
                },
                variant: 'info'
            });

            confirmAddButton.disabled = true;
            confirmAddButton.textContent = 'Adding…';

            try {
                const response = await fetch('/api/books', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    let message = 'We could not add this book right now. Please try again.';
                    try {
                        const errorBody = await response.json();
                        message = errorBody?.detail
                            ?? errorBody?.title
                            ?? errorBody?.message
                            ?? message;
                    } catch {
                        message = `${message} (status ${response.status})`;
                    }

                    logActivity('Book creation failed', {
                        details: {
                            status: response.status,
                            statusText: response.statusText,
                            message
                        },
                        variant: 'error'
                    });

                    setModalFeedback(message, 'error');
                    return;
                }

                const created = await response.json();

                logActivity('Book saved to library', {
                    details: {
                        id: created?.id,
                        status: payload.status
                    },
                    variant: 'success'
                });

                closeStatusModal();
                logActivity('Redirecting to library', { variant: 'info' });
                window.location.href = '/';
            } catch (error) {
                const message = error instanceof Error
                    ? error.message
                    : 'Something went wrong while saving. Please try again.';

                logActivity('Book creation failed', {
                    details: message,
                    variant: 'error'
                });

                setModalFeedback(message, 'error');
            } finally {
                confirmAddButton.disabled = false;
                confirmAddButton.textContent = 'Add to Library';
            }
        }

        function buildBookPayload(book, status, extras = {}) {
            const normalizedStatus = (status ?? readingStatusOptions[0]?.value ?? 'plan-to-read')
                .toString()
                .trim()
                .toLowerCase();
            const title = sanitizeOptionalText(book.title, 200) ?? '';
            const author = sanitizeOptionalText(book.author, 200) ?? '';

            const personalRating = normalizeRatingValue(extras.rating);
            const publicRating = normalizeRatingValue(book.publicRating);
            const avatarUrl = sanitizeOptionalText(extras.avatarUrl, 500);

            const payload = {
                Title: title,
                Author: author,
                Description: sanitizeOptionalText(book.description, 2000),
                Quote: sanitizeOptionalText(book.quote, 500),
                CoverImageUrl: sanitizeOptionalText(book.coverImageUrl, 500),
                Category: sanitizeOptionalText(book.category, 100),
                Isbn: sanitizeOptionalText(book.isbn, 20),
                Status: normalizedStatus,
                IsFavorite: false,
                PersonalRating: personalRating,
                PublicRating: publicRating
            };

            if (avatarUrl) {
                payload.AuthorAvatarUrl = avatarUrl;
            }

            if (extras.remark) {
                payload.Remarks = [extras.remark];
            }

            return payload;
        }

        function tryParseRating() {
            if (!ratingInput) {
                return { value: null, error: null };
            }

            const raw = ratingInput.value.trim();
            if (!raw) {
                return { value: null, error: null };
            }

            const parsed = Number(raw);
            if (!Number.isFinite(parsed)) {
                return { value: null, error: 'Enter a numeric rating between 0 and 5.' };
            }

            if (parsed < 0 || parsed > 5) {
                return { value: null, error: 'Rating must be between 0 and 5.' };
            }

            const rounded = Math.round(parsed * 10) / 10;
            return { value: rounded, error: null };
        }

        function buildRemarkPayload() {
            if (!remarkContentInput) {
                return null;
            }

            const content = remarkContentInput.value.trim();
            if (!content) {
                return null;
            }

            const title = sanitizeOptionalText(remarkTitleInput?.value, 200);
            const limitedContent = content.length > 4000 ? content.slice(0, 4000) : content;
            return {
                Title: title,
                Content: limitedContent
            };
        }

        function resetSupplementaryFields() {
            if (ratingInput) {
                ratingInput.value = '';
            }

            if (remarkTitleInput) {
                remarkTitleInput.value = '';
            }

            if (remarkContentInput) {
                remarkContentInput.value = '';
            }

            if (authorAvatarInput) {
                authorAvatarInput.value = '';
            }
        }

        async function handleSearch() {
            const query = searchInput.value.trim();
            if (!query) {
                showEmptyState();
                return;
            }

            searchButton.disabled = true;
            emptyState.style.display = 'none';
            searchResults.style.display = 'block';
            resultsList.innerHTML = '';
            setFeedback('Searching for matches...');

            try {
                logActivity('Search submitted', {
                    details: { query },
                    variant: 'info'
                });
                logActivity('Dispatching request', {
                    details: {
                        method: 'POST',
                        url: '/api/book-search',
                        payload: { query }
                    },
                    variant: 'info'
                });

                const response = await fetch('/api/book-search', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ query })
                });

                if (!response.ok) {
                    await reportResponseError(response, query);
                    return;
                }

                const data = await response.json();
                const books = Array.isArray(data.books) ? data.books : [];

                logActivity('Response received', {
                    details: {
                        status: response.status,
                        statusText: response.statusText,
                        totalBooks: books.length,
                        sample: books.slice(0, 3).map((book) => ({
                            title: book.title,
                            author: book.author,
                            published: book.published
                        }))
                    },
                    variant: 'success'
                });

                if (books.length === 0) {
                    logActivity('No matching books found', {
                        details: { query },
                        variant: 'warning'
                    });
                    setFeedback('No matching books found. Try another title or author name.', 'error');
                    return;
                }

                setFeedback(`Showing ${books.length} suggestion${books.length === 1 ? '' : 's'}.`, 'success');
                logActivity('Suggestions ready', {
                    details: {
                        count: books.length
                    },
                    variant: 'success'
                });
                renderResults(books);
            } catch (error) {
                const message = error instanceof Error && error.message
                    ? error.message
                    : 'There was an issue fetching suggestions. Please try again.';

                logActivity('Search request failed', {
                    details: {
                        error: message,
                        query
                    },
                    variant: 'error'
                });
                setFeedback(message, 'error');
            } finally {
                searchButton.disabled = false;
            }
        }

        async function reportResponseError(response, query) {
            let message = 'There was an issue fetching suggestions. Please try again.';

            try {
                const errorBody = await response.json();
                message = errorBody?.detail
                    ?? errorBody?.title
                    ?? errorBody?.message
                    ?? message;
            } catch {
                message = `${message} (status ${response.status})`;
            }

            logActivity('Search request failed', {
                details: {
                    status: response.status,
                    statusText: response.statusText,
                    message,
                    query
                },
                variant: 'error'
            });

            setFeedback(message, 'error');
        }

        function renderResults(results) {
            const html = results.map((book) => {
                const rawTitle = book.title ?? 'Untitled';
                const rawAuthor = book.author ?? 'Unknown author';
                const title = escapeHtml(rawTitle);
                const author = escapeHtml(rawAuthor);

                const safePublished = sanitizeOptionalText(book.published, 120);
                const safeLanguage = sanitizeOptionalText(book.language, 60);
                const safeDescription = sanitizeOptionalText(book.description, 2000);
                const safeQuote = sanitizeOptionalText(book.quote, 500);
                const safeCategory = sanitizeOptionalText(book.category, 100);
                const safeIsbn = sanitizeOptionalText(book.isbn, 20);
                const safeCover = sanitizeOptionalText(book.coverImageUrl, 500);

                const communityRating = typeof book.rating === 'number' && Number.isFinite(book.rating)
                    ? book.rating
                    : null;

                // Build metadata badges
                const metadataBadges = [];
                
                if (safeCategory) {
                    metadataBadges.push(`
                        <span class="book-badge book-badge--category">
                            <svg class="book-badge-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M4 7V4a1 1 0 0 1 1-1h4.586a1 1 0 0 1 .707.293L12 5h7a1 1 0 0 1 1 1v3a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1z"/>
                                <path d="M4 7v10a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1V8"/>
                            </svg>
                            ${escapeHtml(safeCategory)}
                        </span>
                    `);
                }

                if (safePublished) {
                    metadataBadges.push(`
                        <span class="book-badge book-badge--year">
                            <svg class="book-badge-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="3" y="4" width="18" height="18" rx="2" ry="2"/>
                                <line x1="16" y1="2" x2="16" y2="6"/>
                                <line x1="8" y1="2" x2="8" y2="6"/>
                                <line x1="3" y1="10" x2="21" y2="10"/>
                            </svg>
                            ${escapeHtml(safePublished)}
                        </span>
                    `);
                }

                if (safeLanguage) {
                    metadataBadges.push(`
                        <span class="book-badge book-badge--language">
                            <svg class="book-badge-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="12" cy="12" r="10"/>
                                <line x1="2" y1="12" x2="22" y2="12"/>
                                <path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/>
                            </svg>
                            ${escapeHtml(safeLanguage)}
                        </span>
                    `);
                }

                if (safeIsbn) {
                    metadataBadges.push(`
                        <span class="book-badge book-badge--isbn">
                            <svg class="book-badge-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                                <polyline points="14,2 14,8 20,8"/>
                                <line x1="16" y1="13" x2="8" y2="13"/>
                                <line x1="16" y1="17" x2="8" y2="17"/>
                                <polyline points="10,9 9,9 8,9"/>
                            </svg>
                            ${escapeHtml(safeIsbn)}
                        </span>
                    `);
                }

                if (communityRating !== null) {
                    metadataBadges.push(`
                        <span class="book-badge book-badge--rating">
                            <svg class="book-badge-icon" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="1">
                                <polygon points="12,2 15.09,8.26 22,9.27 17,14.14 18.18,21.02 12,17.77 5.82,21.02 7,14.14 2,9.27 8.91,8.26"/>
                            </svg>
                            ${communityRating.toFixed(1)}/5
                        </span>
                    `);
                }

                // Description with better formatting
                const description = safeDescription ? `
                    <div class="book-description">
                        <p>${escapeHtml(safeDescription)}</p>
                    </div>
                ` : '';

                // Quote with better styling
                const quote = safeQuote ? `
                    <div class="book-quote-container">
                        <svg class="book-quote-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M3 21c3 0 7-1 7-8V5c0-1.25-.756-2.017-2-2H4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2 1 0 1 0 1 1v1c0 1-1 2-2 2s-1 .008-1 1.031V20c0 1 0 1 1 1z"/>
                            <path d="M15 21c3 0 7-1 7-8V5c0-1.25-.757-2.017-2-2h-4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2h.75c0 2.25.25 4-2.75 4v3c0 1 0 1 1 1z"/>
                        </svg>
                        <blockquote class="book-quote">${escapeHtml(safeQuote)}</blockquote>
                    </div>
                ` : '';

                const cover = safeCover ? escapeAttribute(safeCover) : '';
                const coverData = escapeAttribute(safeCover ?? '');
                const initialCover = cover || placeholderCover;
                const descriptionData = escapeAttribute(safeDescription ?? '');
                const categoryData = escapeAttribute(safeCategory ?? '');
                const quoteData = escapeAttribute(safeQuote ?? '');
                const isbnData = escapeAttribute(safeIsbn ?? '');
                const ratingData = communityRating !== null
                    ? escapeAttribute(communityRating.toFixed(1))
                    : '';

                return `
                    <div class="search-result-item">
                        <div class="book-cover">
                            <img src="${initialCover}" data-cover-src="${cover}" alt="${title}" loading="lazy" referrerpolicy="no-referrer" />
                        </div>
                        <div class="book-info">
                            <div class="book-header">
                                <h3 class="book-title">${title}</h3>
                                <p class="book-author">by ${author}</p>
                            </div>
                            
                            ${metadataBadges.length > 0 ? `
                                <div class="book-metadata">
                                    ${metadataBadges.join('')}
                                </div>
                            ` : ''}
                            
                            ${description}
                            ${quote}
                        </div>
                        <div class="book-actions">
                            <button class="add-book-btn"
                                data-title="${escapeAttribute(rawTitle)}"
                                data-author="${escapeAttribute(rawAuthor)}"
                                data-description="${descriptionData}"
                                data-cover="${coverData}"
                                data-category="${categoryData}"
                                data-quote="${quoteData}"
                                data-isbn="${isbnData}"
                                data-public-rating="${ratingData}">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <line x1="12" y1="5" x2="12" y2="19"></line>
                                    <line x1="5" y1="12" x2="19" y2="12"></line>
                                </svg>
                                Add to Library
                            </button>
                        </div>
                    </div>
                `;
            }).join('');

            resultsList.innerHTML = html;
            applyCoverImageFallbacks();
        }

        function escapeHtml(value) {
            if (value === undefined || value === null) {
                return '';
            }

            return String(value).replace(/[&<>"']/g, (char) => {
                switch (char) {
                    case '&':
                        return '&amp;';
                    case '<':
                        return '&lt;';
                    case '>':
                        return '&gt;';
                    case '"':
                        return '&quot;';
                    case "'":
                        return '&#39;';
                    default:
                        return char;
                }
            });
        }

        function generateStarRating(rating) {
            const stars = [];
            const fullStars = Math.floor(rating);
            const hasHalfStar = rating % 1 >= 0.5;
            const emptyStars = 5 - fullStars - (hasHalfStar ? 1 : 0);

            // Full stars
            for (let i = 0; i < fullStars; i++) {
                stars.push('<svg class="star star--full" viewBox="0 0 24 24" fill="currentColor"><polygon points="12,2 15.09,8.26 22,9.27 17,14.14 18.18,21.02 12,17.77 5.82,21.02 7,14.14 2,9.27 8.91,8.26"></polygon></svg>');
            }

            // Half star
            if (hasHalfStar) {
                stars.push('<svg class="star star--half" viewBox="0 0 24 24"><defs><linearGradient id="half-fill"><stop offset="50%" stop-color="currentColor"/><stop offset="50%" stop-color="transparent"/></linearGradient></defs><polygon points="12,2 15.09,8.26 22,9.27 17,14.14 18.18,21.02 12,17.77 5.82,21.02 7,14.14 2,9.27 8.91,8.26" fill="url(#half-fill)" stroke="currentColor" stroke-width="1"></polygon></svg>');
            }

            // Empty stars
            for (let i = 0; i < emptyStars; i++) {
                stars.push('<svg class="star star--empty" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1"><polygon points="12,2 15.09,8.26 22,9.27 17,14.14 18.18,21.02 12,17.77 5.82,21.02 7,14.14 2,9.27 8.91,8.26"></polygon></svg>');
            }

            return stars.join('');
        }

        function escapeAttribute(value) {
            return escapeHtml(value ?? '');
        }

        function logActivity(message, options = {}) {
            const { details, variant = 'info' } = options;
            if (!activityLogEntries) {
                return;
            }

            hideActivityLogEmptyState();

            const entry = document.createElement('div');
            entry.className = `activity-log-entry activity-log-entry--${variant}`;

            const header = document.createElement('div');
            header.className = 'activity-log-entry-header';

            const timestamp = document.createElement('span');
            timestamp.className = 'activity-log-timestamp';
            timestamp.textContent = new Date().toLocaleTimeString();

            const messageSpan = document.createElement('span');
            messageSpan.className = 'activity-log-message';
            messageSpan.textContent = message;

            header.append(timestamp, messageSpan);
            entry.append(header);

            if (details !== undefined) {
                const detailsBlock = document.createElement('pre');
                detailsBlock.className = 'activity-log-details';
                detailsBlock.textContent = formatLogDetails(details);
                entry.append(detailsBlock);
            }

            activityLogEntries.append(entry);
            activityLogEntries.scrollTop = activityLogEntries.scrollHeight;
        }

        function hideActivityLogEmptyState() {
            if (activityLogEmpty) {
                activityLogEmpty.style.display = 'none';
            }
        }

        function showActivityLogEmptyState() {
            if (activityLogEmpty) {
                activityLogEmpty.style.display = 'flex';
            }
        }

        function resetActivityLog() {
            if (!activityLogEntries) {
                return;
            }

            const entries = activityLogEntries.querySelectorAll('.activity-log-entry');
            entries.forEach((entry) => entry.remove());
            showActivityLogEmptyState();
        }

        function hasActivityLogEntries() {
            return Boolean(activityLogEntries?.querySelector('.activity-log-entry'));
        }

        function formatLogDetails(details) {
            if (details === null || details === undefined) {
                return '';
            }

            if (typeof details === 'string') {
                return details;
            }

            try {
                return JSON.stringify(details, null, 2);
            } catch {
                return String(details);
            }
        }

        function applyCoverImageFallbacks() {
            const images = resultsList.querySelectorAll('img[data-cover-src]');
            images.forEach((img) => {
                const coverSrc = img.dataset.coverSrc;
                if (!coverSrc) {
                    markImageAsFallback(img);
                    return;
                }

                const handleError = () => {
                    markImageAsFallback(img);
                };

                img.addEventListener('error', handleError, { once: true });

                if (img.complete && img.naturalWidth === 0) {
                    handleError();
                }
            });
        }

        function markImageAsFallback(img) {
            if (img.dataset.fallbackApplied === 'true') {
                return;
            }

            img.dataset.fallbackApplied = 'true';
            img.removeAttribute('data-cover-src');
            img.src = placeholderCover;
        }

        showEmptyState();
    </script>
}
