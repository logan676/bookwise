@page
@model AddBookModel
@{
    ViewData["Title"] = "Add Book";
}

<div class="search-page-container">
    <!-- Search Bar -->
    <div class="search-section">
        <div class="search-bar-container">
            <div class="search-input-wrapper">
                <svg class="search-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="11" cy="11" r="8"/>
                    <path d="m21 21-4.35-4.35"/>
                </svg>
                <input type="search" 
                       id="book-search" 
                       placeholder="Search for a book by title or author..." 
                       class="search-input" 
                       autocomplete="off" />
                <button type="button" class="search-submit" id="execute-search">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="11" cy="11" r="8"/>
                        <path d="m21 21-4.35-4.35"/>
                    </svg>
                    Search
                </button>
            </div>
        </div>
    </div>

    <!-- Empty State (shown when no search) -->
    <div class="empty-state-container" id="empty-state">
        <div class="empty-state-content">
            <div class="book-icon">
                <svg viewBox="0 0 64 64" fill="none">
                    <path d="M10 16C10 12.6863 12.6863 10 16 10H32C35.3137 10 38 12.6863 38 16V52C38 55.3137 35.3137 58 32 58H16C12.6863 58 10 55.3137 10 52V16Z" fill="#E2F2FF"/>
                    <path d="M54 16C54 12.6863 51.3137 10 48 10H32C28.6863 10 26 12.6863 26 16V52C26 55.3137 28.6863 58 32 58H48C51.3137 58 54 55.3137 54 52V16Z" fill="#B8E0FF"/>
                    <path d="M21 24H30" stroke="#0D6EFD" stroke-width="3" stroke-linecap="round"/>
                    <path d="M21 34H30" stroke="#0D6EFD" stroke-width="3" stroke-linecap="round"/>
                    <path d="M34 24H43" stroke="#0D6EFD" stroke-width="3" stroke-linecap="round"/>
                    <path d="M34 34H43" stroke="#0D6EFD" stroke-width="3" stroke-linecap="round"/>
                </svg>
            </div>
            <h2>Add a new book to your library</h2>
            <p>Start by searching for a book by its title or author in the search bar above. We'll find it for you!</p>
            <button type="button" class="start-searching-btn" id="start-searching">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="11" cy="11" r="8"/>
                    <path d="m21 21-4.35-4.35"/>
                </svg>
                Start Searching
            </button>
        </div>
    </div>

    <!-- Search Results -->
    <div class="search-results-container" id="search-results" style="display: none;">
        <h2 class="search-results-title">Search Results</h2>
        <div id="search-feedback" class="search-feedback" style="display: none;"></div>
        <div class="search-results-list" id="results-list">
            <!-- Results will be populated by JavaScript -->
        </div>
    </div>

    <!-- Activity Log -->
    <div class="activity-log-container" id="activity-log">
        <div class="activity-log-header">
            <h2 class="activity-log-title">Activity Timeline</h2>
            <button type="button" class="clear-log-btn" id="clear-log">
                Clear log
            </button>
        </div>
        <div class="activity-log-body" id="activity-log-entries" aria-live="polite">
            <div class="activity-log-empty" id="activity-log-empty" data-empty-state>
                <p>Start a search to inspect every request and response that powers this page.</p>
            </div>
        </div>
    </div>
</div>

<div class="status-modal-backdrop" id="status-modal" hidden>
    <div class="status-modal-panel" role="dialog" aria-modal="true" aria-labelledby="status-modal-title" aria-describedby="status-modal-description" tabindex="-1">
        <button type="button" class="status-modal-close" id="status-modal-close" aria-label="Close">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
        </button>
        <header class="status-modal-header">
            <p class="status-modal-eyebrow" id="status-modal-description">Choose how you want to track this title.</p>
            <h2 class="status-modal-title" id="status-modal-title">Add to your library</h2>
            <p class="status-modal-book" id="status-modal-book"></p>
        </header>
        <div class="status-modal-options" id="reading-status-options"></div>
        <footer class="status-modal-footer">
            <span class="status-modal-feedback" id="status-modal-feedback" role="alert"></span>
            <button type="button" class="status-modal-submit" id="confirm-add-book">
                Add to Library
            </button>
        </footer>
    </div>
</div>

@section Scripts {
    <script>
        // Search functionality
        const searchInput = document.getElementById('book-search');
        const searchButton = document.getElementById('execute-search');
        const emptyState = document.getElementById('empty-state');
        const searchResults = document.getElementById('search-results');
        const resultsList = document.getElementById('results-list');
        const startSearchingBtn = document.getElementById('start-searching');
        const searchFeedback = document.getElementById('search-feedback');
        const activityLogEntries = document.getElementById('activity-log-entries');
        const activityLogEmpty = document.getElementById('activity-log-empty');
        const clearLogButton = document.getElementById('clear-log');
        const placeholderCover = 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="60" height="90"><rect width="100%" height="100%" fill="#e2e8f0"/><text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" font-family="Arial, sans-serif" font-size="9" fill="#64748b">No Cover</text></svg>');
        const statusModal = document.getElementById('status-modal');
        const statusModalPanel = document.querySelector('.status-modal-panel');
        const statusModalClose = document.getElementById('status-modal-close');
        const statusOptionsContainer = document.getElementById('reading-status-options');
        const statusModalBook = document.getElementById('status-modal-book');
        const statusModalFeedback = document.getElementById('status-modal-feedback');
        const confirmAddButton = document.getElementById('confirm-add-book');

        const readingStatusOptions = [
            {
                value: 'plan-to-read',
                label: 'Save for Later',
                helper: 'Queue this title for when you have time to enjoy it.'
            },
            {
                value: 'reading',
                label: 'Currently Reading',
                helper: 'Start tracking it right away while you dive in.'
            },
            {
                value: 'read',
                label: 'Finished',
                helper: 'Log it as completed and celebrate the win.'
            }
        ];

        let selectedBook = null;
        let selectedStatus = readingStatusOptions[0]?.value ?? 'plan-to-read';

        initializeStatusOptions();

        startSearchingBtn?.addEventListener('click', () => {
            searchInput.focus();
        });

        searchInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                event.preventDefault();
                handleSearch();
            }
        });

        searchInput.addEventListener('input', () => {
            if (!searchInput.value.trim()) {
                showEmptyState();
            }
        });

        searchButton.addEventListener('click', handleSearch);

        clearLogButton?.addEventListener('click', resetActivityLog);

        statusModalClose?.addEventListener('click', closeStatusModal);

        statusModal?.addEventListener('click', (event) => {
            if (event.target === statusModal) {
                closeStatusModal();
            }
        });

        confirmAddButton?.addEventListener('click', submitSelectedBook);

        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' && isModalOpen()) {
                closeStatusModal();
            }
        });

        resultsList.addEventListener('click', (event) => {
            const button = event.target.closest('.add-book-btn');
            if (!button) {
                return;
            }

            const book = extractBookData(button);
            if (!book.title || !book.author) {
                logActivity('Add book blocked', {
                    details: book,
                    variant: 'error'
                });
                setFeedback('Unable to add this suggestion right now. Try searching again.', 'error');
                return;
            }

            logActivity('Add book requested', {
                details: {
                    title: book.title,
                    author: book.author
                },
                variant: 'info'
            });

            openStatusModal(book);
        });

        function showEmptyState() {
            emptyState.style.display = 'block';
            searchResults.style.display = 'none';
            resultsList.innerHTML = '';
            setFeedback('');
            if (hasActivityLogEntries()) {
                logActivity('Reset search state', { variant: 'info' });
            }
        }

        function setFeedback(message, state) {
            if (!message) {
                searchFeedback.style.display = 'none';
                searchFeedback.textContent = '';
                searchFeedback.className = 'search-feedback';
                return;
            }

            const classes = ['search-feedback'];
            if (state) {
                classes.push(state);
            }

            searchFeedback.className = classes.join(' ');
            searchFeedback.textContent = message;
            searchFeedback.style.display = 'block';
        }

        function initializeStatusOptions() {
            if (!statusOptionsContainer) {
                return;
            }

            statusOptionsContainer.innerHTML = readingStatusOptions.map((option, index) => `
                <label class="status-option">
                    <input type="radio" name="reading-status" value="${option.value}" ${index === 0 ? 'checked' : ''}>
                    <span class="status-option-content">
                        <span class="status-option-label">${option.label}</span>
                        <span class="status-option-helper">${option.helper}</span>
                    </span>
                </label>
            `).join('');

            statusOptionsContainer.addEventListener('change', (event) => {
                const input = event.target;
                if (input instanceof HTMLInputElement && input.name === 'reading-status') {
                    selectedStatus = input.value;
                    clearModalFeedback();
                }
            });
        }

        function extractBookData(button) {
            const {
                title = '',
                author = '',
                description = '',
                cover = '',
                category = ''
            } = button.dataset;

            return {
                title: title.trim(),
                author: author.trim(),
                description: description.trim(),
                coverImageUrl: cover.trim(),
                category: category.trim()
            };
        }

        function openStatusModal(book) {
            if (!statusModal) {
                return;
            }

            selectedBook = book;
            selectedStatus = readingStatusOptions[0]?.value ?? 'plan-to-read';

            clearModalFeedback();

            if (statusModalBook) {
                statusModalBook.textContent = `${book.title} · ${book.author}`;
            }

            const radios = statusOptionsContainer?.querySelectorAll('input[name="reading-status"]');
            radios?.forEach((input, index) => {
                input.checked = index === 0;
            });

            document.body.classList.add('modal-open');
            statusModal.removeAttribute('hidden');
            statusModal.classList.add('is-open');

            queueMicrotask(() => {
                const focusTarget = statusOptionsContainer?.querySelector('input[name="reading-status"]');
                if (focusTarget instanceof HTMLElement) {
                    focusTarget.focus();
                } else if (statusModalPanel instanceof HTMLElement) {
                    statusModalPanel.focus();
                }
            });
        }

        function closeStatusModal() {
            if (!statusModal) {
                return;
            }

            statusModal.classList.remove('is-open');
            statusModal.setAttribute('hidden', 'hidden');
            document.body.classList.remove('modal-open');
            selectedBook = null;
        }

        function isModalOpen() {
            return statusModal?.classList.contains('is-open') ?? false;
        }

        function clearModalFeedback() {
            if (!statusModalFeedback) {
                return;
            }

            statusModalFeedback.textContent = '';
            statusModalFeedback.className = 'status-modal-feedback';
        }

        function setModalFeedback(message, state) {
            if (!statusModalFeedback) {
                return;
            }

            const classes = ['status-modal-feedback'];
            if (state) {
                classes.push(`status-modal-feedback--${state}`);
            }

            statusModalFeedback.className = classes.join(' ');
            statusModalFeedback.textContent = message;
        }

        async function submitSelectedBook() {
            if (!confirmAddButton) {
                return;
            }

            if (!selectedBook) {
                setModalFeedback('Select a book before adding it to your library.', 'error');
                return;
            }

            const payload = buildBookPayload(selectedBook, selectedStatus);

            if (!payload.title || !payload.author) {
                setModalFeedback('We need a title and author to add this book.', 'error');
                return;
            }

            logActivity('Saving book to library', {
                details: {
                    title: payload.title,
                    author: payload.author,
                    status: payload.status
                },
                variant: 'info'
            });

            confirmAddButton.disabled = true;
            confirmAddButton.textContent = 'Adding…';

            try {
                const response = await fetch('/api/books', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    let message = 'We could not add this book right now. Please try again.';
                    try {
                        const errorBody = await response.json();
                        message = errorBody?.detail
                            ?? errorBody?.title
                            ?? errorBody?.message
                            ?? message;
                    } catch {
                        message = `${message} (status ${response.status})`;
                    }

                    logActivity('Book creation failed', {
                        details: {
                            status: response.status,
                            statusText: response.statusText,
                            message
                        },
                        variant: 'error'
                    });

                    setModalFeedback(message, 'error');
                    return;
                }

                const created = await response.json();

                logActivity('Book saved to library', {
                    details: {
                        id: created?.id,
                        status: payload.status
                    },
                    variant: 'success'
                });

                closeStatusModal();
                logActivity('Redirecting to library', { variant: 'info' });
                window.location.href = '/';
            } catch (error) {
                const message = error instanceof Error
                    ? error.message
                    : 'Something went wrong while saving. Please try again.';

                logActivity('Book creation failed', {
                    details: message,
                    variant: 'error'
                });

                setModalFeedback(message, 'error');
            } finally {
                confirmAddButton.disabled = false;
                confirmAddButton.textContent = 'Add to Library';
            }
        }

        function buildBookPayload(book, status) {
            const normalizedStatus = (status ?? readingStatusOptions[0]?.value ?? 'plan-to-read')
                .toString()
                .trim()
                .toLowerCase();
            const title = (book.title ?? '').trim();
            const author = (book.author ?? '').trim();

            return {
                title,
                author,
                description: book.description ? book.description.trim() : null,
                coverImageUrl: book.coverImageUrl ? book.coverImageUrl.trim() : null,
                category: book.category ? book.category.trim() : null,
                status: normalizedStatus,
                isFavorite: false,
                rating: null
            };
        }

        async function handleSearch() {
            const query = searchInput.value.trim();
            if (!query) {
                showEmptyState();
                return;
            }

            searchButton.disabled = true;
            emptyState.style.display = 'none';
            searchResults.style.display = 'block';
            resultsList.innerHTML = '';
            setFeedback('Searching for books...');

            try {
                logActivity('Search submitted', {
                    details: { query },
                    variant: 'info'
                });
                logActivity('Dispatching request', {
                    details: {
                        method: 'POST',
                        url: '/api/book-search',
                        payload: { query }
                    },
                    variant: 'info'
                });

                const response = await fetch('/api/book-search', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ query })
                });

                if (!response.ok) {
                    await reportResponseError(response, query);
                    return;
                }

                const data = await response.json();
                const books = Array.isArray(data.books) ? data.books : [];

                logActivity('Response received', {
                    details: {
                        status: response.status,
                        statusText: response.statusText,
                        totalBooks: books.length,
                        sample: books.slice(0, 3).map((book) => ({
                            title: book.title,
                            author: book.author,
                            published: book.published
                        }))
                    },
                    variant: 'success'
                });

                if (books.length === 0) {
                    logActivity('No matching books found', {
                        details: { query },
                        variant: 'warning'
                    });
                    setFeedback('No matching books found. Try a different keyword.', 'error');
                    return;
                }

                setFeedback(`Showing ${books.length} suggestion${books.length === 1 ? '' : 's'}.`, 'success');
                logActivity('Suggestions ready', {
                    details: {
                        count: books.length
                    },
                    variant: 'success'
                });
                renderResults(books);
            } catch (error) {
                const message = error instanceof Error && error.message
                    ? error.message
                    : 'There was an issue fetching suggestions. Please try again.';

                logActivity('Search request failed', {
                    details: message,
                    variant: 'error'
                });
                setFeedback(message, 'error');
            } finally {
                searchButton.disabled = false;
            }
        }

        async function reportResponseError(response, query) {
            let message = 'There was an issue fetching suggestions. Please try again.';

            try {
                const errorBody = await response.json();
                message = errorBody?.detail
                    ?? errorBody?.title
                    ?? errorBody?.message
                    ?? message;
            } catch {
                message = `${message} (status ${response.status})`;
            }

            logActivity('Search request failed', {
                details: {
                    status: response.status,
                    statusText: response.statusText,
                    message,
                    query
                },
                variant: 'error'
            });

            setFeedback(message, 'error');
        }

        function renderResults(results) {
            const html = results.map((book) => {
                const rawTitle = book.title ?? 'Untitled';
                const rawAuthor = book.author ?? 'Unknown author';
                const title = escapeHtml(rawTitle);
                const author = escapeHtml(rawAuthor);
                const metaParts = [];

                if (book.published) {
                    metaParts.push(`Published: ${escapeHtml(book.published)}`);
                }

                if (book.language) {
                    metaParts.push(`Language: ${escapeHtml(book.language)}`);
                }

                const metadata = metaParts.length > 0
                    ? `<p class="book-details">${metaParts.join(' | ')}</p>`
                    : '';

                const description = book.description
                    ? `<p class="book-details">${escapeHtml(book.description)}</p>`
                    : '';

                const cover = book.coverImageUrl
                    ? escapeAttribute(book.coverImageUrl)
                    : placeholderCover;

                const coverData = escapeAttribute(book.coverImageUrl ?? '');
                const descriptionData = escapeAttribute(book.description ?? '');
                const categoryData = escapeAttribute(book.category ?? '');

                return `
                    <div class="search-result-item">
                        <div class="book-cover">
                            <img src="${cover}" alt="${title}" />
                        </div>
                        <div class="book-info">
                            <h3 class="book-title">${title}</h3>
                            <p class="book-author">by ${author}</p>
                            ${metadata}
                            ${description}
                        </div>
                        <button class="add-book-btn"
                            data-title="${escapeAttribute(rawTitle)}"
                            data-author="${escapeAttribute(rawAuthor)}"
                            data-description="${descriptionData}"
                            data-cover="${coverData}"
                            data-category="${categoryData}">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <line x1="12" y1="5" x2="12" y2="19"></line>
                                <line x1="5" y1="12" x2="19" y2="12"></line>
                            </svg>
                            Add
                        </button>
                    </div>
                `;
            }).join('');

            resultsList.innerHTML = html;
        }

        function escapeHtml(value) {
            if (value === undefined || value === null) {
                return '';
            }

            return String(value).replace(/[&<>"']/g, (char) => {
                switch (char) {
                    case '&':
                        return '&amp;';
                    case '<':
                        return '&lt;';
                    case '>':
                        return '&gt;';
                    case '"':
                        return '&quot;';
                    case "'":
                        return '&#39;';
                    default:
                        return char;
                }
            });
        }

        function escapeAttribute(value) {
            return escapeHtml(value ?? '');
        }

        function logActivity(message, options = {}) {
            const { details, variant = 'info' } = options;
            if (!activityLogEntries) {
                return;
            }

            hideActivityLogEmptyState();

            const entry = document.createElement('div');
            entry.className = `activity-log-entry activity-log-entry--${variant}`;

            const header = document.createElement('div');
            header.className = 'activity-log-entry-header';

            const timestamp = document.createElement('span');
            timestamp.className = 'activity-log-timestamp';
            timestamp.textContent = new Date().toLocaleTimeString();

            const messageSpan = document.createElement('span');
            messageSpan.className = 'activity-log-message';
            messageSpan.textContent = message;

            header.append(timestamp, messageSpan);
            entry.append(header);

            if (details !== undefined) {
                const detailsBlock = document.createElement('pre');
                detailsBlock.className = 'activity-log-details';
                detailsBlock.textContent = formatLogDetails(details);
                entry.append(detailsBlock);
            }

            activityLogEntries.append(entry);
            activityLogEntries.scrollTop = activityLogEntries.scrollHeight;
        }

        function hideActivityLogEmptyState() {
            if (activityLogEmpty) {
                activityLogEmpty.style.display = 'none';
            }
        }

        function showActivityLogEmptyState() {
            if (activityLogEmpty) {
                activityLogEmpty.style.display = 'flex';
            }
        }

        function resetActivityLog() {
            if (!activityLogEntries) {
                return;
            }

            const entries = activityLogEntries.querySelectorAll('.activity-log-entry');
            entries.forEach((entry) => entry.remove());
            showActivityLogEmptyState();
        }

        function hasActivityLogEntries() {
            return Boolean(activityLogEntries?.querySelector('.activity-log-entry'));
        }

        function formatLogDetails(details) {
            if (details === null || details === undefined) {
                return '';
            }

            if (typeof details === 'string') {
                return details;
            }

            try {
                return JSON.stringify(details, null, 2);
            } catch {
                return String(details);
            }
        }

        showEmptyState();
    </script>
}
