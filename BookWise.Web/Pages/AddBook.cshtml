@page
@model AddBookModel
@{
    ViewData["Title"] = "Add Book";
}

<div class="search-page-container">
    <!-- Search Bar -->
    <div class="search-section">
        <div class="search-bar-container">
            <div class="search-input-wrapper">
                <svg class="search-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="11" cy="11" r="8"/>
                    <path d="m21 21-4.35-4.35"/>
                </svg>
                <input type="search" 
                       id="book-search" 
                       placeholder="Search for a book by title or author..." 
                       class="search-input" 
                       autocomplete="off" />
                <label class="sr-only" for="search-mode">Search scope</label>
                <select id="search-mode" class="search-mode-select">
                    <option value="title" selected>Title</option>
                    <option value="author">Author</option>
                </select>
                <button type="button" class="search-submit" id="execute-search">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="11" cy="11" r="8"/>
                        <path d="m21 21-4.35-4.35"/>
                    </svg>
                    Search
                </button>
            </div>
        </div>
    </div>

    <!-- Empty State (shown when no search) -->
    <div class="empty-state-container" id="empty-state">
        <div class="empty-state-content">
            <div class="book-icon">
                <svg viewBox="0 0 64 64" fill="none">
                    <path d="M10 16C10 12.6863 12.6863 10 16 10H32C35.3137 10 38 12.6863 38 16V52C38 55.3137 35.3137 58 32 58H16C12.6863 58 10 55.3137 10 52V16Z" fill="#E2F2FF"/>
                    <path d="M54 16C54 12.6863 51.3137 10 48 10H32C28.6863 10 26 12.6863 26 16V52C26 55.3137 28.6863 58 32 58H48C51.3137 58 54 55.3137 54 52V16Z" fill="#B8E0FF"/>
                    <path d="M21 24H30" stroke="#0D6EFD" stroke-width="3" stroke-linecap="round"/>
                    <path d="M21 34H30" stroke="#0D6EFD" stroke-width="3" stroke-linecap="round"/>
                    <path d="M34 24H43" stroke="#0D6EFD" stroke-width="3" stroke-linecap="round"/>
                    <path d="M34 34H43" stroke="#0D6EFD" stroke-width="3" stroke-linecap="round"/>
                </svg>
            </div>
            <h2>Add a new book to your library</h2>
            <p>Start by searching for a book by its title or author in the search bar above. We'll find it for you!</p>
            <button type="button" class="start-searching-btn" id="start-searching">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="11" cy="11" r="8"/>
                    <path d="m21 21-4.35-4.35"/>
                </svg>
                Start Searching
            </button>
        </div>
    </div>

    <!-- Search Results -->
    <div class="search-results-container" id="search-results" style="display: none;">
        <h2 class="search-results-title">Search Results</h2>
        <div id="search-feedback" class="search-feedback" style="display: none;"></div>
        <div class="search-results-list" id="results-list">
            <!-- Results will be populated by JavaScript -->
        </div>
    </div>

    <!-- Activity Log -->
    <div class="activity-log-container" id="activity-log">
        <div class="activity-log-header">
            <h2 class="activity-log-title">Activity Timeline</h2>
            <button type="button" class="clear-log-btn" id="clear-log">
                Clear log
            </button>
        </div>
        <div class="activity-log-body" id="activity-log-entries" aria-live="polite">
            <div class="activity-log-empty" id="activity-log-empty" data-empty-state>
                <p>Start a search to inspect every request and response that powers this page.</p>
            </div>
        </div>
    </div>
</div>

<div class="status-modal-backdrop" id="status-modal" hidden>
    <div class="status-modal-panel" role="dialog" aria-modal="true" aria-labelledby="status-modal-title" aria-describedby="status-modal-description" tabindex="-1">
        <button type="button" class="status-modal-close" id="status-modal-close" aria-label="Close">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
        </button>
        <header class="status-modal-header">
            <p class="status-modal-eyebrow" id="status-modal-description">Choose how you want to track this title.</p>
            <h2 class="status-modal-title" id="status-modal-title">Add to your library</h2>
            <p class="status-modal-book" id="status-modal-book"></p>
        </header>
        <div class="status-modal-options" id="reading-status-options"></div>
        <div class="status-modal-form-group">
            <label for="book-rating" class="status-modal-label">Rating (optional)</label>
            <input type="number"
                   id="book-rating"
                   class="status-modal-input"
                   name="book-rating"
                   min="0"
                   max="5"
                   step="0.5"
                   inputmode="decimal"
                   placeholder="e.g. 4.5" />
            <p class="status-modal-helper">Use a value between 0 and 5 to capture your first impression.</p>
        </div>
        <div class="status-modal-form-group">
            <label for="remark-content" class="status-modal-label">Personal remark (optional)</label>
            <input type="text"
                   id="remark-title"
                   class="status-modal-input"
                   name="remark-title"
                   maxlength="200"
                   placeholder="Give your remark a short title (optional)" />
            <textarea id="remark-content"
                      class="status-modal-textarea"
                      name="remark-content"
                      maxlength="4000"
                      rows="4"
                      placeholder="Capture any thoughts you'd like to remember when you revisit this book."></textarea>
            <p class="status-modal-helper">Remark is saved privately to your library and can be edited later.</p>
        </div>
        <footer class="status-modal-footer">
            <span class="status-modal-feedback" id="status-modal-feedback" role="alert"></span>
            <button type="button" class="status-modal-submit" id="confirm-add-book">
                Add to Library
            </button>
        </footer>
    </div>
</div>

@section Scripts {
    <script>
        // Search functionality
        const searchInput = document.getElementById('book-search');
        const searchButton = document.getElementById('execute-search');
        const searchModeSelect = document.getElementById('search-mode');
        const emptyState = document.getElementById('empty-state');
        const searchResults = document.getElementById('search-results');
        const resultsList = document.getElementById('results-list');
        const startSearchingBtn = document.getElementById('start-searching');
        const searchFeedback = document.getElementById('search-feedback');
        const activityLogEntries = document.getElementById('activity-log-entries');
        const activityLogEmpty = document.getElementById('activity-log-empty');
        const clearLogButton = document.getElementById('clear-log');
        const placeholderCover = 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="60" height="90"><rect width="100%" height="100%" fill="#e2e8f0"/><text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" font-family="Arial, sans-serif" font-size="9" fill="#64748b">No Cover</text></svg>');
        const statusModal = document.getElementById('status-modal');
        const statusModalPanel = document.querySelector('.status-modal-panel');
        const statusModalClose = document.getElementById('status-modal-close');
        const statusOptionsContainer = document.getElementById('reading-status-options');
        const statusModalBook = document.getElementById('status-modal-book');
        const statusModalFeedback = document.getElementById('status-modal-feedback');
        const confirmAddButton = document.getElementById('confirm-add-book');
        const ratingInput = document.getElementById('book-rating');
        const remarkTitleInput = document.getElementById('remark-title');
        const remarkContentInput = document.getElementById('remark-content');

        const readingStatusOptions = [
            {
                value: 'plan-to-read',
                label: 'Save for Later',
                helper: 'Queue this title for when you have time to enjoy it.'
            },
            {
                value: 'reading',
                label: 'Currently Reading',
                helper: 'Start tracking it right away while you dive in.'
            },
            {
                value: 'read',
                label: 'Finished',
                helper: 'Log it as completed and celebrate the win.'
            }
        ];

        let selectedBook = null;
        let selectedStatus = readingStatusOptions[0]?.value ?? 'plan-to-read';

        initializeStatusOptions();

        startSearchingBtn?.addEventListener('click', () => {
            searchInput.focus();
        });

        searchInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                event.preventDefault();
                handleSearch();
            }
        });

        searchInput.addEventListener('input', () => {
            if (!searchInput.value.trim()) {
                showEmptyState();
            }
        });

        searchButton.addEventListener('click', handleSearch);

        searchModeSelect?.addEventListener('change', () => {
            const mode = resolveSearchMode();
            logActivity('Search mode updated', {
                details: { searchBy: mode },
                variant: 'info'
            });
        });

        clearLogButton?.addEventListener('click', resetActivityLog);

        statusModalClose?.addEventListener('click', closeStatusModal);

        statusModal?.addEventListener('click', (event) => {
            if (event.target === statusModal) {
                closeStatusModal();
            }
        });

        confirmAddButton?.addEventListener('click', submitSelectedBook);

        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' && isModalOpen()) {
                closeStatusModal();
            }
        });

        resultsList.addEventListener('click', (event) => {
            const button = event.target.closest('.add-book-btn');
            if (!button) {
                return;
            }

            const book = extractBookData(button);
            if (!book.title || !book.author) {
                logActivity('Add book blocked', {
                    details: book,
                    variant: 'error'
                });
                setFeedback('Unable to add this suggestion right now. Try searching again.', 'error');
                return;
            }

            logActivity('Add book requested', {
                details: {
                    title: book.title,
                    author: book.author
                },
                variant: 'info'
            });

            openStatusModal(book);
        });

        function showEmptyState() {
            emptyState.style.display = 'block';
            searchResults.style.display = 'none';
            resultsList.innerHTML = '';
            setFeedback('');
            if (hasActivityLogEntries()) {
                logActivity('Reset search state', { variant: 'info' });
            }
        }

        function setFeedback(message, state) {
            if (!message) {
                searchFeedback.style.display = 'none';
                searchFeedback.textContent = '';
                searchFeedback.className = 'search-feedback';
                return;
            }

            const classes = ['search-feedback'];
            if (state) {
                classes.push(state);
            }

            searchFeedback.className = classes.join(' ');
            searchFeedback.textContent = message;
            searchFeedback.style.display = 'block';
        }

        function initializeStatusOptions() {
            if (!statusOptionsContainer) {
                return;
            }

            statusOptionsContainer.innerHTML = readingStatusOptions.map((option, index) => `
                <label class="status-option">
                    <input type="radio" name="reading-status" value="${option.value}" ${index === 0 ? 'checked' : ''}>
                    <span class="status-option-content">
                        <span class="status-option-label">${option.label}</span>
                        <span class="status-option-helper">${option.helper}</span>
                    </span>
                </label>
            `).join('');

            statusOptionsContainer.addEventListener('change', (event) => {
                const input = event.target;
                if (input instanceof HTMLInputElement && input.name === 'reading-status') {
                    selectedStatus = input.value;
                    clearModalFeedback();
                }
            });
        }

        function extractBookData(button) {
            const {
                title = '',
                author = '',
                description = '',
                cover = '',
                category = '',
                quote = '',
                isbn = '',
                rating = ''
            } = button.dataset;

            const toNullable = (value) => {
                const trimmed = (value ?? '').trim();
                return trimmed.length > 0 ? trimmed : null;
            };

            const parsedRating = Number.parseFloat(rating);

            return {
                title: title.trim(),
                author: author.trim(),
                description: toNullable(description),
                coverImageUrl: toNullable(cover),
                category: toNullable(category),
                quote: toNullable(quote),
                isbn: toNullable(isbn),
                rating: Number.isFinite(parsedRating) ? parsedRating : null
            };
        }

        function openStatusModal(book) {
            if (!statusModal) {
                return;
            }

            selectedBook = book;
            selectedStatus = readingStatusOptions[0]?.value ?? 'plan-to-read';

            clearModalFeedback();
            resetSupplementaryFields();

            if (statusModalBook) {
                statusModalBook.textContent = `${book.title} · ${book.author}`;
            }

            const radios = statusOptionsContainer?.querySelectorAll('input[name="reading-status"]');
            radios?.forEach((input, index) => {
                input.checked = index === 0;
            });

            document.body.classList.add('modal-open');
            statusModal.removeAttribute('hidden');
            statusModal.classList.add('is-open');

            queueMicrotask(() => {
                const focusTarget = statusOptionsContainer?.querySelector('input[name="reading-status"]');
                if (focusTarget instanceof HTMLElement) {
                    focusTarget.focus();
                } else if (statusModalPanel instanceof HTMLElement) {
                    statusModalPanel.focus();
                }
            });
        }

        function closeStatusModal() {
            if (!statusModal) {
                return;
            }

            statusModal.classList.remove('is-open');
            statusModal.setAttribute('hidden', 'hidden');
            document.body.classList.remove('modal-open');
            selectedBook = null;
            resetSupplementaryFields();
        }

        function isModalOpen() {
            return statusModal?.classList.contains('is-open') ?? false;
        }

        function clearModalFeedback() {
            if (!statusModalFeedback) {
                return;
            }

            statusModalFeedback.textContent = '';
            statusModalFeedback.className = 'status-modal-feedback';
        }

        function setModalFeedback(message, state) {
            if (!statusModalFeedback) {
                return;
            }

            const classes = ['status-modal-feedback'];
            if (state) {
                classes.push(`status-modal-feedback--${state}`);
            }

            statusModalFeedback.className = classes.join(' ');
            statusModalFeedback.textContent = message;
        }

        async function submitSelectedBook() {
            if (!confirmAddButton) {
                return;
            }

            if (!selectedBook) {
                setModalFeedback('Select a book before adding it to your library.', 'error');
                return;
            }

            const { value: ratingValue, error: ratingError } = tryParseRating();
            if (ratingError) {
                setModalFeedback(ratingError, 'error');
                return;
            }

            const remarkPayload = buildRemarkPayload();

            const payload = buildBookPayload(selectedBook, selectedStatus, {
                rating: ratingValue,
                remark: remarkPayload
            });

            if (!payload.title || !payload.author) {
                setModalFeedback('We need a title and author to add this book.', 'error');
                return;
            }

            logActivity('Saving book to library', {
                details: {
                    title: payload.title,
                    author: payload.author,
                    status: payload.status
                },
                variant: 'info'
            });

            confirmAddButton.disabled = true;
            confirmAddButton.textContent = 'Adding…';

            try {
                const response = await fetch('/api/books', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    let message = 'We could not add this book right now. Please try again.';
                    try {
                        const errorBody = await response.json();
                        message = errorBody?.detail
                            ?? errorBody?.title
                            ?? errorBody?.message
                            ?? message;
                    } catch {
                        message = `${message} (status ${response.status})`;
                    }

                    logActivity('Book creation failed', {
                        details: {
                            status: response.status,
                            statusText: response.statusText,
                            message
                        },
                        variant: 'error'
                    });

                    setModalFeedback(message, 'error');
                    return;
                }

                const created = await response.json();

                logActivity('Book saved to library', {
                    details: {
                        id: created?.id,
                        status: payload.status
                    },
                    variant: 'success'
                });

                closeStatusModal();
                logActivity('Redirecting to library', { variant: 'info' });
                window.location.href = '/';
            } catch (error) {
                const message = error instanceof Error
                    ? error.message
                    : 'Something went wrong while saving. Please try again.';

                logActivity('Book creation failed', {
                    details: message,
                    variant: 'error'
                });

                setModalFeedback(message, 'error');
            } finally {
                confirmAddButton.disabled = false;
                confirmAddButton.textContent = 'Add to Library';
            }
        }

        function buildBookPayload(book, status, extras = {}) {
            const normalizedStatus = (status ?? readingStatusOptions[0]?.value ?? 'plan-to-read')
                .toString()
                .trim()
                .toLowerCase();
            const title = (book.title ?? '').trim();
            const author = (book.author ?? '').trim();
            const sanitize = (value) => {
                if (typeof value !== 'string') {
                    return null;
                }

                const trimmed = value.trim();
                return trimmed.length > 0 ? trimmed : null;
            };

            const resolvedRating = (() => {
                if (typeof extras.rating === 'number' && Number.isFinite(extras.rating)) {
                    return extras.rating;
                }

                if (typeof book.rating === 'number' && Number.isFinite(book.rating)) {
                    return book.rating;
                }

                return null;
            })();

            const normalizedRating = resolvedRating !== null
                ? Math.min(5, Math.max(0, Math.round(resolvedRating * 10) / 10))
                : null;

            const payload = {
                title,
                author,
                description: sanitize(book.description),
                quote: sanitize(book.quote),
                coverImageUrl: sanitize(book.coverImageUrl),
                category: sanitize(book.category),
                isbn: sanitize(book.isbn),
                status: normalizedStatus,
                isFavorite: false,
                rating: normalizedRating
            };

            if (extras.remark) {
                payload.remarks = [extras.remark];
            }

            return payload;
        }

        function resolveSearchMode() {
            return searchModeSelect?.value === 'author' ? 'author' : 'title';
        }

        function tryParseRating() {
            if (!ratingInput) {
                return { value: null, error: null };
            }

            const raw = ratingInput.value.trim();
            if (!raw) {
                return { value: null, error: null };
            }

            const parsed = Number(raw);
            if (!Number.isFinite(parsed)) {
                return { value: null, error: 'Enter a numeric rating between 0 and 5.' };
            }

            if (parsed < 0 || parsed > 5) {
                return { value: null, error: 'Rating must be between 0 and 5.' };
            }

            const rounded = Math.round(parsed * 10) / 10;
            return { value: rounded, error: null };
        }

        function buildRemarkPayload() {
            if (!remarkContentInput) {
                return null;
            }

            const content = remarkContentInput.value.trim();
            if (!content) {
                return null;
            }

            const title = remarkTitleInput?.value.trim();
            return {
                title: title ? title : null,
                content
            };
        }

        function resetSupplementaryFields() {
            if (ratingInput) {
                ratingInput.value = '';
            }

            if (remarkTitleInput) {
                remarkTitleInput.value = '';
            }

            if (remarkContentInput) {
                remarkContentInput.value = '';
            }
        }

        async function handleSearch() {
            const query = searchInput.value.trim();
            if (!query) {
                showEmptyState();
                return;
            }

            const searchBy = resolveSearchMode();
            const isAuthorSearch = searchBy === 'author';

            searchButton.disabled = true;
            emptyState.style.display = 'none';
            searchResults.style.display = 'block';
            resultsList.innerHTML = '';
            setFeedback(isAuthorSearch ? 'Searching for books by author...' : 'Searching for books...');

            try {
                logActivity('Search submitted', {
                    details: { query, searchBy },
                    variant: 'info'
                });
                logActivity('Dispatching request', {
                    details: {
                        method: 'POST',
                        url: '/api/book-search',
                        payload: { query, searchBy }
                    },
                    variant: 'info'
                });

                const response = await fetch('/api/book-search', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ query, searchBy })
                });

                if (!response.ok) {
                    await reportResponseError(response, query, searchBy);
                    return;
                }

                const data = await response.json();
                const books = Array.isArray(data.books) ? data.books : [];

                logActivity('Response received', {
                    details: {
                        status: response.status,
                        statusText: response.statusText,
                        totalBooks: books.length,
                        searchBy,
                        sample: books.slice(0, 3).map((book) => ({
                            title: book.title,
                            author: book.author,
                            published: book.published
                        }))
                    },
                    variant: 'success'
                });

                if (books.length === 0) {
                    logActivity('No matching books found', {
                        details: { query, searchBy },
                        variant: 'warning'
                    });
                    setFeedback(
                        isAuthorSearch
                            ? 'No books found for that author. Try a different name.'
                            : 'No matching books found. Try a different keyword.',
                        'error');
                    return;
                }

                setFeedback(`Showing ${books.length} suggestion${books.length === 1 ? '' : 's'}.`, 'success');
                logActivity('Suggestions ready', {
                    details: {
                        count: books.length,
                        searchBy
                    },
                    variant: 'success'
                });
                renderResults(books);
            } catch (error) {
                const message = error instanceof Error && error.message
                    ? error.message
                    : 'There was an issue fetching suggestions. Please try again.';

                logActivity('Search request failed', {
                    details: {
                        error: message,
                        query,
                        searchBy
                    },
                    variant: 'error'
                });
                setFeedback(message, 'error');
            } finally {
                searchButton.disabled = false;
            }
        }

        async function reportResponseError(response, query, searchBy) {
            let message = 'There was an issue fetching suggestions. Please try again.';

            try {
                const errorBody = await response.json();
                message = errorBody?.detail
                    ?? errorBody?.title
                    ?? errorBody?.message
                    ?? message;
            } catch {
                message = `${message} (status ${response.status})`;
            }

            logActivity('Search request failed', {
                details: {
                    status: response.status,
                    statusText: response.statusText,
                    message,
                    query,
                    searchBy
                },
                variant: 'error'
            });

            setFeedback(message, 'error');
        }

        function renderResults(results) {
            const html = results.map((book) => {
                const rawTitle = book.title ?? 'Untitled';
                const rawAuthor = book.author ?? 'Unknown author';
                const title = escapeHtml(rawTitle);
                const author = escapeHtml(rawAuthor);
                const metaParts = [];

                if (book.published) {
                    metaParts.push(`Published: ${escapeHtml(book.published)}`);
                }

                if (book.language) {
                    metaParts.push(`Language: ${escapeHtml(book.language)}`);
                }

                if (typeof book.rating === 'number' && Number.isFinite(book.rating)) {
                    metaParts.push(`Rating: ${escapeHtml(book.rating.toFixed(1))}/5`);
                }

                if (book.category) {
                    metaParts.push(`Category: ${escapeHtml(book.category)}`);
                }

                if (book.isbn) {
                    metaParts.push(`ISBN: ${escapeHtml(book.isbn)}`);
                }

                const metadata = metaParts.length > 0
                    ? `<p class="book-details">${metaParts.join(' | ')}</p>`
                    : '';

                const description = book.description
                    ? `<p class="book-details">${escapeHtml(book.description)}</p>`
                    : '';

                const quote = book.quote
                    ? `<p class="book-details book-quote">“${escapeHtml(book.quote)}”</p>`
                    : '';

                const cover = book.coverImageUrl
                    ? escapeAttribute(book.coverImageUrl)
                    : '';

                const coverData = escapeAttribute(book.coverImageUrl ?? '');
                const initialCover = cover || placeholderCover;
                const descriptionData = escapeAttribute(book.description ?? '');
                const categoryData = escapeAttribute(book.category ?? '');
                const quoteData = escapeAttribute(book.quote ?? '');
                const isbnData = escapeAttribute(book.isbn ?? '');
                const ratingData = (typeof book.rating === 'number' && Number.isFinite(book.rating))
                    ? escapeAttribute(book.rating.toFixed(1))
                    : '';

                return `
                    <div class="search-result-item">
                        <div class="book-cover">
                            <img src="${initialCover}" data-cover-src="${cover}" alt="${title}" loading="lazy" referrerpolicy="no-referrer" />
                        </div>
                        <div class="book-info">
                            <h3 class="book-title">${title}</h3>
                            <p class="book-author">by ${author}</p>
                            ${metadata}
                            ${description}
                            ${quote}
                        </div>
                        <button class="add-book-btn"
                            data-title="${escapeAttribute(rawTitle)}"
                            data-author="${escapeAttribute(rawAuthor)}"
                            data-description="${descriptionData}"
                            data-cover="${coverData}"
                            data-category="${categoryData}"
                            data-quote="${quoteData}"
                            data-isbn="${isbnData}"
                            data-rating="${ratingData}">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <line x1="12" y1="5" x2="12" y2="19"></line>
                                <line x1="5" y1="12" x2="19" y2="12"></line>
                            </svg>
                            Add
                        </button>
                    </div>
                `;
            }).join('');

            resultsList.innerHTML = html;
            applyCoverImageFallbacks();
        }

        function escapeHtml(value) {
            if (value === undefined || value === null) {
                return '';
            }

            return String(value).replace(/[&<>"']/g, (char) => {
                switch (char) {
                    case '&':
                        return '&amp;';
                    case '<':
                        return '&lt;';
                    case '>':
                        return '&gt;';
                    case '"':
                        return '&quot;';
                    case "'":
                        return '&#39;';
                    default:
                        return char;
                }
            });
        }

        function escapeAttribute(value) {
            return escapeHtml(value ?? '');
        }

        function logActivity(message, options = {}) {
            const { details, variant = 'info' } = options;
            if (!activityLogEntries) {
                return;
            }

            hideActivityLogEmptyState();

            const entry = document.createElement('div');
            entry.className = `activity-log-entry activity-log-entry--${variant}`;

            const header = document.createElement('div');
            header.className = 'activity-log-entry-header';

            const timestamp = document.createElement('span');
            timestamp.className = 'activity-log-timestamp';
            timestamp.textContent = new Date().toLocaleTimeString();

            const messageSpan = document.createElement('span');
            messageSpan.className = 'activity-log-message';
            messageSpan.textContent = message;

            header.append(timestamp, messageSpan);
            entry.append(header);

            if (details !== undefined) {
                const detailsBlock = document.createElement('pre');
                detailsBlock.className = 'activity-log-details';
                detailsBlock.textContent = formatLogDetails(details);
                entry.append(detailsBlock);
            }

            activityLogEntries.append(entry);
            activityLogEntries.scrollTop = activityLogEntries.scrollHeight;
        }

        function hideActivityLogEmptyState() {
            if (activityLogEmpty) {
                activityLogEmpty.style.display = 'none';
            }
        }

        function showActivityLogEmptyState() {
            if (activityLogEmpty) {
                activityLogEmpty.style.display = 'flex';
            }
        }

        function resetActivityLog() {
            if (!activityLogEntries) {
                return;
            }

            const entries = activityLogEntries.querySelectorAll('.activity-log-entry');
            entries.forEach((entry) => entry.remove());
            showActivityLogEmptyState();
        }

        function hasActivityLogEntries() {
            return Boolean(activityLogEntries?.querySelector('.activity-log-entry'));
        }

        function formatLogDetails(details) {
            if (details === null || details === undefined) {
                return '';
            }

            if (typeof details === 'string') {
                return details;
            }

            try {
                return JSON.stringify(details, null, 2);
            } catch {
                return String(details);
            }
        }

        function applyCoverImageFallbacks() {
            const images = resultsList.querySelectorAll('img[data-cover-src]');
            images.forEach((img) => {
                const coverSrc = img.dataset.coverSrc;
                if (!coverSrc) {
                    markImageAsFallback(img);
                    return;
                }

                const handleError = () => {
                    markImageAsFallback(img);
                };

                img.addEventListener('error', handleError, { once: true });

                if (img.complete && img.naturalWidth === 0) {
                    handleError();
                }
            });
        }

        function markImageAsFallback(img) {
            if (img.dataset.fallbackApplied === 'true') {
                return;
            }

            img.dataset.fallbackApplied = 'true';
            img.removeAttribute('data-cover-src');
            img.src = placeholderCover;
        }

        showEmptyState();
    </script>
}
